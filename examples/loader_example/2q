package main

import (
	"flag"
	"github.com/brnsampson/ezconf/file"
	"github.com/brnsampson/ezconf/httpconf"
	"github.com/brnsampson/optional"
)

// Default values for MyServiceConfig
const (
	DefaultMyServerConfigNodeID        = 1
	DefaultMyServerConfigSecretKey     = "/etc/myapp/secretkey.txt"
	DefaultMyServerConfigAddress       = "127.0.0.1"
	DefaultMyServerConfigPort          = 443
	DefaultMyServerConfigTlsCert       = "/etc/myapp/tls/cert.pem"
	DefaultMyServerConfigTlsPrivateKey = "/etc/myapp/tls/key.pem"
	DefaultMyServerConfigTlsEnabled    = true
	DefaultMyServerConfigTlsSkipVerify = false
)

// Default values for MyDBConfig
const (
	DefaultMyDBConfigAddress = "127.0.0.1"
	DefaultMyDBConfigPort    = 8080
)

// flag variables
var (
	myDBAddressFlag optional.Str
	myDBPortFlag    optional.Uint16
)

type loader[T any] interface {
	Update() (T, error)
	Prev() T
}

// SetupMyAppConfigFlags adds command line flags to support this config. It is suggested that
// you just call NewLoader() which does this for you, but you may do this yourself if you want more
// control. As an example:
//
// SetupMyAppConfigFlags()
// l := MyAppConfigLoader{}
// myappconf, err := l.Update(flag.CommandLine)
func SetupMyAppConfigFlags() {
	// TODO: Add flags for any config field which has the `flag:"true"` field tag
	flag.Var(&myDBAddressFlag, "myDBAddress", "MyDBConfig Address Value. Type: String, Default: '127.0.0.1'")
	flag.Var(&myDBPortFlag, "myDBPort", "MyDBConfig Port Value. Type: uint16, Default: 8080")
	return
}

// NewLoader sets up required flags, creates a new loader, updates it, and returns the loaded loader.
func NewLoader() (MyAppConfigLoader, error) {
	SetupMyAppConfigFlags()

	l := MyAppConfigLoader{}
	_, err := l.Update()
	return l, err
}

type MyAppConfigLoader struct {
	MyService MyServiceConfigLoader
	MyDB      MyDBConfigLoader
	Flags     *flag.FlagSet
	previous  MyAppConfig
}

func (l *MyAppConfigLoader) Prev() MyAppConfig {
	return l.previous
}

func (l *MyAppConfigLoader) Update() (config MyAppConfig, err error) {
	// TODO: check myAppConfigPath for the value of the -config flag and use that as the config file to load.
	// TODO: load l from env vars.
	myService, err := l.MyService.Update()
	if err != nil {
		return
	}

	myDB, err := l.MyDB.Update()
	if err != nil {
		return
	}

	l.previous = MyAppConfig{MyService: myService, MyDB: myDB}

	return l.previous, err
}

// Loader for MyServiceConfig type
type MyServiceConfigLoader struct {
	Name         string          `env:"MY_APP_MY_SERVICE_NAME"`
	Description  optional.Str    `env:"MY_APP_MY_SERVICE_DESCRIPTION"`
	NodeID       optional.Uint32 `json:"node" toml:"node" yaml:"node" env:"MY_APP_MY_SERVICE_NODE"`
	Priority     optional.Uint16 `env:"MY_APP_MY_SERVICE_PRIORITY"`
	SecretKey    file.SecretFile `env:"MY_APP_MY_SERVICE_SECRET_KEY"`
	ServerConfig httpconf.HttpServerLoader
	previous     MyServiceConfig
}

func NewMyServiceConfigLoader() MyServiceConfigLoader {
	l := MyServiceConfigLoader{}
	return l
}

func (l *MyServiceConfigLoader) Update() (c MyServiceConfig, err error) {
	// TODO
	return c, nil
}

func (l MyServiceConfigLoader) Prev() MyServiceConfig {
	return l.previous
}

// Loader for MyDBConfig type
type MyDBConfigLoader struct {
	Address  optional.Str    `env:"MY_APP_MY_DB_ADDRESS"`
	Port     optional.Uint16 `env:"MY_APP_MY_DB_PORT"`
	previous MyDBConfig
}

func (l *MyDBConfigLoader) Update() (c MyDBConfig, err error) {
	// Flags are defined as package variables above. Flags override all other config sources.
	l.Address = optional.Or(myDBAddressFlag, l.Address)
	l.Port = optional.Or(myDBPortFlag, l.Port)

	newConfig := l.previous

	newConfig.Address = optional.GetOr(l.Address, DefaultMyDBConfigAddress)
	newConfig.Port = optional.GetOr(l.Port, DefaultMyDBConfigPort)

	l.previous = newConfig
	return l.previous, nil
}

func (l MyDBConfigLoader) Prev() MyDBConfig {
	return l.previous
}
